package main

//#include <stdlib.h>
import "C"
import (
	"bytes"
	"fmt"
	"unsafe"

	"github.com/btcsuite/btcd/txscript"
	"github.com/btcsuite/btcd/wire"
)

var globalLastEngineErr error
var globalLastExecErr error

func mapFlag(flags *uint32, bitcoinCoreFlags uint32, bitcoinCoreBit int, flag txscript.ScriptFlags) {
	if (bitcoinCoreFlags & (1 << bitcoinCoreBit)) > 0 {
		*flags |= (uint32)(flag)
	}
}

// Bitcoin Core's script verification flags do not translate 1:1 to btcd's flags
func translateFlags(flags uint32) txscript.ScriptFlags {
	var ret uint32 = 0

	mapFlag(&ret, flags, 0, txscript.ScriptBip16)
	mapFlag(&ret, flags, 1, txscript.ScriptVerifyStrictEncoding)
	mapFlag(&ret, flags, 2, txscript.ScriptVerifyDERSignatures)
	mapFlag(&ret, flags, 3, txscript.ScriptVerifyLowS)
	mapFlag(&ret, flags, 4, txscript.ScriptStrictMultiSig) // NULL DUMMY in bitcoin core
	mapFlag(&ret, flags, 5, txscript.ScriptVerifySigPushOnly)
	mapFlag(&ret, flags, 6, txscript.ScriptVerifyMinimalData)
	mapFlag(&ret, flags, 7, txscript.ScriptDiscourageUpgradableNops)
	mapFlag(&ret, flags, 8, txscript.ScriptVerifyCleanStack)
	mapFlag(&ret, flags, 9, txscript.ScriptVerifyCheckLockTimeVerify)
	mapFlag(&ret, flags, 10, txscript.ScriptVerifyCheckSequenceVerify)
	mapFlag(&ret, flags, 11, txscript.ScriptVerifyWitness)
	mapFlag(&ret, flags, 12, txscript.ScriptVerifyDiscourageUpgradeableWitnessProgram)
	mapFlag(&ret, flags, 13, txscript.ScriptVerifyMinimalIf)
	mapFlag(&ret, flags, 14, txscript.ScriptVerifyNullFail)
	mapFlag(&ret, flags, 15, txscript.ScriptVerifyWitnessPubKeyType)
	// TODO mapFlag(&ret, flags, 16, )
	if (flags & (1 << 16)) > 0 {
		//	panic("cant translate this flag")
	}
	mapFlag(&ret, flags, 17, txscript.ScriptVerifyTaproot)
	mapFlag(&ret, flags, 18, txscript.ScriptVerifyDiscourageUpgradeableTaprootVersion)
	mapFlag(&ret, flags, 19, txscript.ScriptVerifyDiscourageOpSuccess)
	mapFlag(&ret, flags, 20, txscript.ScriptVerifyDiscourageUpgradeablePubkeyType)

	return (txscript.ScriptFlags)(ret)
}

//export btcd_print_errors
func btcd_print_errors() {
	fmt.Println("btcd engine error:", globalLastEngineErr)
	fmt.Println("btcd exec error:", globalLastExecErr)
}

//export btcd_verify_script
func btcd_verify_script(script_pub *C.char, script_pub_size C.size_t, tx_bytes *C.char, tx_size C.size_t, input_index C.int, flags C.uint) C.int {
	scriptPubKey := C.GoBytes(unsafe.Pointer(script_pub), C.int(script_pub_size))
	txSlice := C.GoBytes(unsafe.Pointer(tx_bytes), C.int(tx_size))

	tx := &wire.MsgTx{}
	reader := bytes.NewReader(txSlice)
	txErr := tx.BtcDecode(reader, 70016, wire.WitnessEncoding)
	if txErr != nil {
		return 0
	}

	if tx.SerializeSize() != int(tx_size) {
		return 0
	}

	globalLastEngineErr = nil
	globalLastExecErr = nil

	scriptFlags := translateFlags(uint32(flags))
	vm, engineErr := txscript.NewEngine(scriptPubKey, tx, int(input_index), scriptFlags, nil, nil, -1, nil)
	if engineErr != nil {
		globalLastEngineErr = engineErr
		return 0
	}

	execErr := vm.Execute()
	if execErr != nil {
		globalLastExecErr = execErr
		return 0
	}

	return 1
}

func main() {}
